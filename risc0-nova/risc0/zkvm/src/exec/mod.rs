// Copyright 2023 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! The execution phase is implemented by this module.
//!
//! The result of the execution phase is [Session], which contains one or more
//! [Segment]s, each which contains an execution trace of the specified program.

mod env;
mod io;
mod monitor;
use std::{array, cell::RefCell, fmt::Debug, io::Write, mem::take, rc::Rc, str};

use anyhow::{anyhow, bail, Result};
use risc0_zkvm_platform::{
    memory::{HEAP_INITIAL_ADDRESS, MEM_SIZE},
    syscall::{
        ecall, halt,
        reg_abi::{REG_A0, REG_A1, REG_A2, REG_A3, REG_A4, REG_A7},
    },
    PAGE_SIZE, WORD_SIZE,
};
use rrs_lib::{instruction_executor::InstructionExecutor, memories::VecMemory, HartState, Memory};
use serde::{Deserialize, Serialize};

pub use self::env::{ExecutorEnv, ExecutorEnvBuilder};
use self::monitor::MemoryMonitor;
use crate::{
    opcode::{MajorType, OpCode},
    ExitCode, MemoryImage, Program, Session,
};

/// The number of cycles required to compress a SHA-256 block.
const SHA_CYCLES: usize = 72;

/// The Executor provides an implementation for the execution phase.
///
/// The proving phase uses an execution trace generated by the Executor.
pub struct Executor<'a> {
    env: ExecutorEnv<'a>,
    // pre_image: MemoryImage,
    /// MemoryMonitor
    pub monitor: MemoryMonitor,
    pre_pc: u64,
    pc: u64,
    anonymous_heap_watermark: u64,
    // segments: Vec<Segment>,
    insn_counter: u32,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct SyscallRecord {
    pub to_guest: Vec<u64>,
    pub regs: (u64, u64),
}

#[derive(Clone)]
pub struct OpCodeResult {
    pc: u64,
    exit_code: Option<ExitCode>,
    extra_cycles: usize,
    syscall: Option<SyscallRecord>,
}

impl OpCodeResult {
    fn new(
        pc: u64,
        exit_code: Option<ExitCode>,
        extra_cycles: usize,
        syscall: Option<SyscallRecord>,
    ) -> Self {
        Self {
            pc,
            exit_code,
            extra_cycles,
            syscall,
        }
    }
}

// Capture the journal output in a buffer that we can access afterwards.
#[derive(Clone, Default)]
struct Journal {
    buf: Rc<RefCell<Vec<u8>>>,
}

impl Write for Journal {
    fn write(&mut self, bytes: &[u8]) -> std::io::Result<usize> {
        self.buf.borrow_mut().write(bytes)
    }

    fn flush(&mut self) -> std::io::Result<()> {
        self.buf.borrow_mut().flush()
    }
}

impl<'a> Executor<'a> {
    /// Construct a new [Executor] from a [MemoryImage] and entry point.
    pub fn new(env: ExecutorEnv<'a>, image: MemoryImage, pc: u64) -> Self {
        // let pre_image = image.clone();
        let monitor = MemoryMonitor::new(image);

        Self {
            env,
            // pre_image,
            monitor,
            pre_pc: pc,
            pc,
            anonymous_heap_watermark: HEAP_INITIAL_ADDRESS as u64,
            // segments: Vec::new(),
            insn_counter: 0,
        }
    }

    /// Construct a new [Executor] from an ELF binary.
    pub fn from_elf(env: ExecutorEnv<'a>, elf: &[u8]) -> Result<Self> {
        let program = Program::load_elf(&elf, MEM_SIZE as u64)?;
        let image = MemoryImage::new(&program, PAGE_SIZE as u64);
        Ok(Self::new(env, image, program.entry))
    }

    /// Run the executor until [ExitCode::Paused] or [ExitCode::Halted] is
    /// reached, producing a [Session] as a result.
    pub fn run(&mut self) -> Result<Session> {
        self.monitor.clear_session();

        //        let journal = Journal::default();
        // self.env
        //     .io
        //     .borrow_mut()
        //     .with_write_fd(fileno::JOURNAL, journal.clone());

        let mut run_loop = || -> Result<ExitCode> {
            loop {
                if let Some(exit_code) = self.step()? {
                    // let total_cycles = self.total_cycles();
                    // log::debug!("exit_code: {exit_code:?}, total_cycles: {total_cycles}");
                    // assert!(total_cycles <= (1 << self.env.segment_limit_po2));
                    // let pre_image = self.pre_image.clone();
                    let syscalls = take(&mut self.monitor.syscalls);
                    // let faults = take(&mut self.monitor.faults);
                    // self.segments.push(Segment::new(
                    //     pre_image,
                    //     post_image_id,
                    //     self.pre_pc,
                    //     // faults,
                    //     syscalls,
                    //     exit_code,
                    //     // log2_ceil(total_cycles.next_power_of_two()),
                    // ));
                    match exit_code {
                        ExitCode::SessionLimit => bail!("Session limit exceeded"),
                        ExitCode::Halted(inner) => {
                            println!("success!");
                            return Ok(exit_code);
                        }
                    };
                };
            }
        };

        let exit_code = run_loop()?;
        let mut segments = Vec::new();
        // std::mem::swap(&mut segments, &mut self.segments);
        Ok(Session::new(segments, exit_code))
    }

    /// Execute a single instruction.
    ///
    /// This can be directly used by debuggers.
    pub fn step(&mut self) -> Result<Option<ExitCode>> {
        // if self.session_cycle() > self.env.get_session_limit() {
        //     return Ok(Some(ExitCode::SessionLimit));
        // }

        let insn = self.monitor.load_u32(self.pc);
        let opcode = OpCode::decode(insn, self.pc)?;

        if let Some(op_result) = self.monitor.restore_op() {
            return Ok(self.advance(opcode, op_result));
        }

        let op_result = if opcode.major == MajorType::ECall {
            self.ecall()?
        } else {
            let registers = self.monitor.load_registers(array::from_fn(|idx| idx));
            // if self.pc >= 0x00011ad4 && self.pc <= 0x00011ad4 {
            //     registers.iter().enumerate().for_each(|(idx, value)| {
            //         println!("value loaded {:08x}, idx: {:?}", value, idx,);
            //     });
            // }
            let mut hart = HartState {
                registers,
                pc: self.pc,
                last_register_write: None,
            };

            InstructionExecutor {
                mem: &mut self.monitor,
                hart_state: &mut hart,
            }
            .step()
            .map_err(|err| anyhow!("{:?}", err))?;

            if let Some(idx) = hart.last_register_write {
                self.monitor.store_register(idx, hart.registers[idx]);
            }

            OpCodeResult::new(hart.pc, None, 0, None)
        };
        self.monitor.save_op(op_result.clone());

        // try to execute the next instruction
        // if the segment limit is exceeded:
        // * don't increment the PC
        // * don't record any activity
        // * return ExitCode::SystemSplit
        // otherwise, commit memory and hart

        let segment_limit = self.env.get_segment_limit();
        // let total_pending_cycles = self.total_pending_cycles(&opcode);
        // log::debug!(
        //     "cycle: {}, segment: {}, total: {}",
        //     self.segment_cycle,
        //     total_pending_cycles,
        //     self.total_cycles()
        // );
        // let exit_code = if total_pending_cycles > segment_limit {
        //     Some(ExitCode::SystemSplit(self.insn_counter))
        // } else {
        let exit_code = self.advance(opcode, op_result);
        // };
        Ok(exit_code)
    }

    fn advance(&mut self, opcode: OpCode, op_result: OpCodeResult) -> Option<ExitCode> {
        log::debug!(
            "pc: 0x{:08x}, insn: 0x{:08x} => {:?}",
            self.pc,
            opcode.insn,
            opcode
        );

        self.pc = op_result.pc;
        self.insn_counter += 1;
        self.monitor.commit();
        op_result.exit_code
    }

    // fn total_cycles(&self) -> usize {
    //     self.init_cycles
    //         + self.monitor.total_fault_cycles()
    //         + self.body_cycles
    //         + self.fini_cycles
    //         + SHA_CYCLES
    //         + ZK_CYCLES
    // }

    // fn total_pending_cycles(&self, opcode: &OpCode) -> usize {
    //     // How many cycles are required for the entire segment?
    //     // This sum is based on:
    //     // - ensure we don't split in the middle of a SHA compress
    //     // - each page fault requires 1 PageFault cycle + CYCLES_PER_PAGE cycles
    //     // - leave room for fini_cycles
    //     // - leave room for ZK cycles
    //     self.init_cycles
    //         + self.monitor.total_pending_fault_cycles()
    //         + opcode.cycles
    //         + self.body_cycles
    //         + self.fini_cycles
    //         + SHA_CYCLES
    //         + ZK_CYCLES
    // }

    // fn session_cycle(&self) -> usize {
    //     self.segments.len() * self.env.get_segment_limit() + self.segment_cycle
    // }

    fn ecall(&mut self) -> Result<OpCodeResult> {
        // previously it used REG_TO. Seems it's for RIV32E (embedded version spec). A reference https://github.com/chipsalliance/VeeR-ISS/blob/main/Syscall.cpp#L788-L791
        // here in RIV64 we switch to REG_A7
        match self.monitor.load_register(REG_A7) {
            ecall::HALT => self.ecall_halt(),
            ecall::EXIT => self.ecall_halt(),
            ecall::OUTPUT => self.ecall_output(),
            // ecall::SOFTWARE => self.ecall_software(),
            ecall::FCNTL => self.ecall_fcntl(),
            ecall::OPEN => self.ecall_open(),
            ecall::CLOSE => self.ecall_do_nth(),
            ecall::WRITE => self.ecall_write(),
            ecall::MMAP => self.ecall_mmap(),
            ecall::MUNMAP => self.ecall_munmap(),
            ecall::MINCORE => self.ecall_mincore(),
            ecall::GETTID => self.ecall_gettid(),
            ecall::SIGPROCMASK => self.ecall_do_nth(),
            ecall::SIGNALSTACK => self.ecall_do_nth(),
            ecall::SIGACTION => self.ecall_do_nth(),
            ecall::GETAFFINITY => self.ecall_do_nth(),
            ecall::CLOCKGETTIME => self.ecall_do_nth(),
            ecall => bail!("Unknown ecall {ecall:08x} in decimal {ecall:?}"),
        }
    }

    fn ecall_gettid(&mut self) -> Result<OpCodeResult> {
        const TID_MAGIC: u64 = 1000;
        self.monitor.store_register(REG_A0, TID_MAGIC);
        Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None))
    }

    fn ecall_munmap(&mut self) -> Result<OpCodeResult> {
        let addr = self.monitor.load_register(REG_A0);
        let size = self.monitor.load_register(REG_A1);
        println!("munmap base: {:08x}, size {:08x}", addr, size);
        match self.monitor.image.memory_space.remove_memory_by_base(addr) {
            Ok(_) => {
                self.monitor.store_register(REG_A0, 0u64);
                Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None))
            }
            Err(_) => Err(anyhow!(format!(
                "munmap unallocated memory space with base {:16x}, size {:?}",
                addr, size
            ))),
        }
        // linear memory management via heap
        // if self.heap_addr - size != addr {
        //     return Err(anyhow!("do not support munmap address below heap
        // addr")); }
        // self.heap_addr -= size;
    }

    fn ecall_mincore(&mut self) -> core::result::Result<OpCodeResult, anyhow::Error> {
        let page_size_align = 1u64 << 12u64;
        let page_size_mask = page_size_align - 1;
        let addr = self.monitor.load_register(REG_A0);
        println!(
            "mincore addr {:08b}, in dec {:?}, page_size_mask {:08b}",
            addr, addr, page_size_mask
        );
        if addr & page_size_mask != 0 {
            // error
            self.monitor.store_register(REG_A0, 22u64); // EINVAL
        } else {
            // successful
            self.monitor.store_register(REG_A0, 0u64);
        }
        Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None))
    }

    fn ecall_do_nth(&mut self) -> Result<OpCodeResult> {
        self.monitor.store_register(REG_A0, 0u64);
        Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None))
    }

    fn ecall_mmap(&mut self) -> Result<OpCodeResult> {
        let page_size_align: u64 = 1u64 << 12u64;
        let page_size_mask = page_size_align - 1;
        let desired_addr = self.monitor.load_register(REG_A0);
        let mut desired_page_size = self.monitor.load_register(REG_A1);
        println!(
            "desired_addr: {:08x}, desired_page_size {:08x}, in dec {:?}, page_size_mask {:08x}",
            desired_addr, desired_page_size, desired_page_size, page_size_mask
        );
        if desired_page_size & page_size_mask != 0 {
            // adjust size to align with page size
            desired_page_size += page_size_align - (desired_page_size & page_size_mask)
        }
        let base = if desired_addr > 0 {
            desired_addr
        } else {
            self.anonymous_heap_watermark
        };
        if let Some(_) = self
            .monitor
            .image
            .memory_space
            .get_memory_region_by_addr(base)
        {
            self.monitor.store_register(REG_A0, base);
            return Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None));
            // if memory_region.size != desired_page_size {
            //     return Err(anyhow!(format!(
            //         "do not support same base {:16x}, size {:16x} with
            // different size {:16x}",         base,
            // memory_region.size, desired_page_size     )));
            // } else {
            //     self.monitor.store_register(REG_A0, base);
            //     println!("return cached addr {:16x}, in dec {:?}", base,
            // base);     return Ok(OpCodeResult::new(self.pc +
            // WORD_SIZE as u64, None, 0, None)); }
        }
        let _ = self
            .monitor
            .image
            .memory_space
            .add_memory(
                base,
                desired_page_size,
                Box::new(VecMemory::new(vec![0_u64; desired_page_size as usize / 8])),
            )
            .unwrap();
        self.monitor.store_register(REG_A0, base);
        println!("return addr {:16x}, in dec {:?}", base, base);
        if desired_addr == 0 {
            // increase heap addr as it came from heap addr watermark
            self.anonymous_heap_watermark = base + desired_page_size;
        }
        Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None))
    }

    fn ecall_fcntl(&mut self) -> core::result::Result<OpCodeResult, anyhow::Error> {
        let a0 = self.monitor.load_register(REG_A0); // write A3 length to A0 return value as write convention
        let a1 = self.monitor.load_register(REG_A1); // write A3 length to A0 return value as write convention
        let a2 = self.monitor.load_register(REG_A2); // write A3 length to A0 return value as write convention
        let O_RDONLY = 0;
        let O_WRONLY = 1;
        println!("ecall_fcntl a0 {:16x}, a1 {:16x}, a2 {:16x}", a0, a1, a2);
        let ret_status = match (a0, a1) {
            (1000, 3) => -1, /* return error to stick to blocking-mode, https://github.com/golang/go/blob/688d75b14fd7646d66c18825f22f0a67e9fafd9e/src/internal/syscall/unix/nonblocking_unix.go#L11 */
            _ => 0,
        };
        self.monitor.store_register(REG_A0, ret_status as u64);
        Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None))
    }

    fn ecall_open(&mut self) -> Result<OpCodeResult> {
        let a0 = self.monitor.load_register(REG_A0); // write A3 length to A0 return value as write convention
        let a1 = self.monitor.load_register(REG_A1); // write A3 length to A0 return value as write convention
        let a2 = self.monitor.load_register(REG_A2); // write A3 length to A0 return value as write convention
        let a3 = self.monitor.load_register(REG_A3); // write A3 length to A0 return value as write convention
        let a4 = self.monitor.load_register(REG_A4); // write A3 length to A0 return value as write convention
        let a7 = self.monitor.load_register(REG_A7); // write A3 length to A0 return value as write convention
        println!(
            "ecall_open a0 {:16x}, a1 {:16x}, a2 {:16x}, a3 {:16x}, a4 {:16x}, a7 {:16x}",
            a0, a1, a2, a3, a4, a7
        );
        let MAX_KEY_LENGTH = 20;
        let raw: Vec<u8> = (0..MAX_KEY_LENGTH)
            .map_while(|n| {
                let value = self
                    .monitor
                    .image
                    .memory_space
                    .read_mem(a1 + n, rrs_lib::MemAccessSize::Byte)
                    .unwrap() as u8;
                if value == 0 {
                    None
                } else {
                    Some(value)
                }
            })
            .collect();
        let key = str::from_utf8(&raw);
        let result_code = match key {
            Ok("hello") => 1000i64,
            _ => -100i64,
        };

        self.monitor.store_register(REG_A0, result_code as u64);
        Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None))
    }

    fn ecall_write(&mut self) -> Result<OpCodeResult> {
        println!("got write!");
        let a0 = self.monitor.load_register(REG_A0);
        let a1 = self.monitor.load_register(REG_A1);
        let a2 = self.monitor.load_register(REG_A2);
        let a3 = self.monitor.load_register(REG_A3);

        println!(
            "ecall_write a0 {:16x}, a1 {:16x}, a2 {:16x}, a3 {:16x}",
            a0, a1, a2, a3
        );

        let raw: Vec<u8> = (0..a2)
            .map(|n| {
                self.monitor
                    .image
                    .memory_space
                    .read_mem(a1 + n, rrs_lib::MemAccessSize::Byte)
                    .unwrap() as u8
            })
            .collect();
        println!(
            "ecall_write res {:?}",
            u64::from_le_bytes(raw.try_into().unwrap())
        );

        let value = self.monitor.load_register(REG_A2); // write A2 length to A0 return value as write convention
        self.monitor.store_register(REG_A0, value);
        Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None))
    }

    fn ecall_halt(&mut self) -> Result<OpCodeResult> {
        let halt_type = self.monitor.load_register(REG_A0);
        match halt_type {
            halt::TERMINATE => Ok(OpCodeResult::new(
                self.pc,
                Some(ExitCode::Halted(0)),
                0,
                None,
            )),
            _ => bail!("Illegal halt type: {halt_type}"),
        }
    }

    fn ecall_output(&mut self) -> Result<OpCodeResult> {
        log::debug!("ecall(output)");
        Ok(OpCodeResult::new(self.pc + WORD_SIZE as u64, None, 0, None))
    }
}

/// An event traced from the running VM.
#[allow(dead_code)] // TODO
#[derive(PartialEq)]
pub enum TraceEvent {
    /// An instruction has started at the given program counter
    InstructionStart {
        /// Cycle number since startup
        cycle: u32,
        /// Program counter of the instruction being executed
        pc: u32,
    },

    /// A register has been set
    RegisterSet {
        /// Register ID (0-16)
        reg: usize,
        /// New value in the register
        value: u32,
    },

    /// A memory location has been written
    MemorySet {
        /// Address of word that's been written
        addr: u32,
        /// Value of word that's been written
        value: u32,
    },
}

impl Debug for TraceEvent {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InstructionStart { cycle, pc } => {
                write!(f, "InstructionStart({cycle}, 0x{pc:08X})")
            }
            Self::RegisterSet { reg, value } => write!(f, "RegisterSet({reg}, 0x{value:08X})"),
            Self::MemorySet { addr, value } => write!(f, "MemorySet(0x{addr:08X}, 0x{value:08X})"),
        }
    }
}
